#include <reflowOS/boot/boot_memory.hpp>
#include <cstring>

#define MODULE_STATIC(type) constexpr static type

#define MODULE_ITERATE_TABLE_START(it_var) for(int it_var = 0 ; it_var < 64 ; it_var++) {
#define MODULE_ITERATE_TABLE_END }

namespace reflowOS {
namespace boot 	   {

	struct module_entry
	{
		typedef char  	      name_type[112]; // 112 Byte
		typedef std::uint64_t pointer_type  ; // 8 Byte
		typedef std::uint64_t size_type     ; // 8 Byte		==> Total 128 Byte. 8192 / 128 = 64. 64 Module can be added in Boot Progress.

		MODULE_STATIC(pointer_type) base_pointer = XPAR_MIG_7SERIES_0_BASEADDR;
		MODULE_STATIC(pointer_type) table_size   = 4096;
		MODULE_STATIC(pointer_type) module_size  = 4096 * 2;

		name_type    module_name;
		pointer_type module_pointer;
		size_type    module_size;

	};

	typedef module_entry module_table[64];
	MODULE_STATIC(std::uint64_t) module_table_section  = XPAR_MIG_7SERIES_0_BASEADDR;
	MODULE_STATIC(std::uint64_t) module_entity_section =  module_table_section + 4096;

	void		  module_initialize	   ();

	template <typename ModuleType>
	ModuleType*   module_load  		   (const char*);
	template <typename ModuleType>
	void 		  module_unload		   (const char*);

	void*		  module_find  	 	   (const char*);
	void*		  module_find_empty	   ();
	module_entry* module_find_empty_table();
}
}

void* reflowOS::boot::module_find  	   (const char*);

void* reflowOS::boot::module_find_empty()
{
	module_entry* fnd_table_entry   = (module_entry*)module_table_section,
				* fnd_table_pointer = module_entity_section;

	MODULE_ITERATE_TABLE_START(it_table)
		if(fnd_table_entry[it_table].module_name[0] == 0x00)
			return fnd_table_pointer;
		else
			reinterpret_cast<std::uint64_t>(fnd_table_pointer) += fnd_table_entry[it_table].module_size;
	MODULE_ITERATE_TABLE_END

	return nullptr;
}

reflowOS::boot::module_entry* reflowOS::boot::module_find_empty_table()
{
	module_entry* fnd_table_entry = (module_entry*)module_table_section;

	MODULE_ITERATE_TABLE_START(it_table)
		if(fnd_table_entry[it_table].module_name[0] == 0x00)
			return &fnd_table_entry[it_table];
	MODULE_ITERATE_TABLE_END

	return nullptr;
}

template <typename ModuleType>
ModuleType* reflowOS::boot::load_module  (const char* name)
{
	ModuleType  * mod_entity = reinterpret_cast<ModuleType*>(module_find_empty());
	module_entry* mod_entry  = module_find_empty_table();

	mod_entry->module_pointer = mod_entity;
	mod_entry->module_size    = sizeof(ModuleType);
}

template <typename ModuleType>
ModuleType* reflowOS::boot::unload_module(const char* module_name)
{

}
